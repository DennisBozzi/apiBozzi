<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Services/FelicianoBozzi/TenantService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Services/FelicianoBozzi/TenantService.cs" />
              <option name="originalContent" value="using System.ComponentModel.DataAnnotations;&#10;using apiBozzi.Context;&#10;using apiBozzi.Models;&#10;using apiBozzi.Models.Dtos;&#10;using apiBozzi.Models.FelicianoBozzi;&#10;using apiBozzi.Models.Responses;&#10;using apiBozzi.Utils;&#10;using Microsoft.EntityFrameworkCore;&#10;&#10;namespace apiBozzi.Services.FelicianoBozzi;&#10;&#10;public class TenantService(IServiceProvider serviceProvider) : ServiceBase(serviceProvider)&#10;{&#10;    private readonly ApartmentService _apartmentService = serviceProvider.GetRequiredService&lt;ApartmentService&gt;();&#10;&#10;    #region Main&#10;&#10;    public async Task&lt;TenantResponse&gt; AddTenant(NewTenant dto)&#10;    {&#10;        await ValidateTenant(dto);&#10;        var newTenant = new Tenant(dto)&#10;        {&#10;            Responsible = dto.ResponsibleTenantId.HasValue()&#10;                ? await Context.Tenants.FirstOrDefaultAsync(x =&gt; x.Id == dto.ResponsibleTenantId)&#10;                : null&#10;        };&#10;&#10;        var res = await Context.Tenants.AddAsync(newTenant);&#10;&#10;        await _apartmentService.MakeResponsible(dto.ApartmentId, res.Entity.Id);&#10;&#10;        await Context.SaveChangesAsync();&#10;&#10;        return new TenantResponse(res.Entity);&#10;    }&#10;&#10;    public async Task&lt;PagedResult&lt;TenantResponse&gt;&gt; ListTenants(TenantFilter filter)&#10;    {&#10;        var totalItems = await Context.Tenants.CountAsync();&#10;&#10;        var tenants = await Context.Tenants&#10;            .Skip((filter.Page - 1) * filter.PageSize)&#10;            .Take(filter.PageSize)&#10;            .OrderBy(x =&gt; x.CreatedAt)&#10;            .Select(x =&gt; new TenantResponse(x, true))&#10;            .ToListAsync();&#10;&#10;        var result = new PagedResult&lt;TenantResponse&gt;&#10;        {&#10;            Items = tenants,&#10;            TotalItems = totalItems,&#10;            CurrentPage = filter.Page,&#10;            PageSize = filter.PageSize,&#10;            TotalPages = (int)Math.Ceiling((double)totalItems / filter.PageSize)&#10;        };&#10;&#10;        return result;&#10;    }&#10;&#10;    public async Task&lt;TenantResponse&gt; GetOneTenantAsync(int id)&#10;    {&#10;        var tenant = await Context.Tenants&#10;            .Include(x =&gt; x.Responsible)&#10;            .FirstOrDefaultAsync(x =&gt; x.Id == id);&#10;&#10;        if (tenant == null)&#10;            throw new ValidationException(&quot;O inquilino não foi encontrado.&quot;);&#10;&#10;        var res = new TenantResponse(tenant);&#10;&#10;        var dependents = await Context.Tenants&#10;            .Where(x =&gt; x.Responsible == tenant)&#10;            .ToListAsync();&#10;&#10;        var ap = tenant.Responsible != null&#10;            ? await Context.Apartments.FirstOrDefaultAsync(x =&gt; x.Responsible == tenant.Responsible)&#10;            : await Context.Apartments.FirstOrDefaultAsync(x =&gt; x.Responsible == tenant);&#10;&#10;        if (ap != null)&#10;            res.WithApartment(ap);&#10;&#10;        res.WithDependents(dependents);&#10;&#10;        return res;&#10;    }&#10;&#10;    #endregion&#10;&#10;    private async Task ValidateTenant(NewTenant dto)&#10;    {&#10;        if (!dto.Cpf.IsValidCpf())&#10;            throw new ValidationException(&quot;O CPF informado não é válido.&quot;);&#10;&#10;        if (await Context.Tenants.AnyAsync(x =&gt; x.Cpf == dto.Cpf))&#10;            throw new ValidationException(&quot;O CPF informado já está sendo utilizado.&quot;);&#10;&#10;        if (!dto.Email.IsValidEmail())&#10;            throw new ValidationException(&quot;O Email informado não é valido.&quot;);&#10;&#10;        var responsible = await Context.Tenants&#10;            .Include(x =&gt; x.Responsible)&#10;            .FirstOrDefaultAsync(x =&gt; x.Id == dto.ResponsibleTenantId);&#10;&#10;        if (responsible.HasValue() &amp;&amp; responsible.Responsible.HasValue())&#10;            throw new ValidationException(&quot;O responsável informado é inválido.&quot;);&#10;    }&#10;}" />
              <option name="updatedContent" value="using System.ComponentModel.DataAnnotations;&#10;using apiBozzi.Context;&#10;using apiBozzi.Models;&#10;using apiBozzi.Models.Dtos;&#10;using apiBozzi.Models.FelicianoBozzi;&#10;using apiBozzi.Models.Responses;&#10;using apiBozzi.Utils;&#10;using Microsoft.EntityFrameworkCore;&#10;&#10;namespace apiBozzi.Services.FelicianoBozzi;&#10;&#10;public class TenantService(IServiceProvider serviceProvider) : ServiceBase(serviceProvider)&#10;{&#10;    private readonly ApartmentService _apartmentService = serviceProvider.GetRequiredService&lt;ApartmentService&gt;();&#10;&#10;    #region Main&#10;&#10;    public async Task&lt;TenantResponse&gt; AddTenant(NewTenant dto)&#10;    {&#10;        await ValidateTenant(dto);&#10;        var newTenant = new Tenant(dto)&#10;        {&#10;            Responsible = dto.ResponsibleTenantId.HasValue()&#10;                ? await Context.Tenants.FirstOrDefaultAsync(x =&gt; x.Id == dto.ResponsibleTenantId)&#10;                : null&#10;        };&#10;&#10;        await using var transaction = await Context.Database.BeginTransactionAsync();&#10;        try&#10;        {&#10;            var res = await Context.Tenants.AddAsync(newTenant);&#10;            await Context.SaveChangesAsync(); // Gera o ID&#10;            await _apartmentService.MakeResponsible(dto.ApartmentId, res.Entity.Id);&#10;            await transaction.CommitAsync();&#10;            return new TenantResponse(res.Entity);&#10;        }&#10;        catch&#10;        {&#10;            await transaction.RollbackAsync();&#10;            throw;&#10;        }&#10;    }&#10;&#10;    public async Task&lt;PagedResult&lt;TenantResponse&gt;&gt; ListTenants(TenantFilter filter)&#10;    {&#10;        var totalItems = await Context.Tenants.CountAsync();&#10;&#10;        var tenants = await Context.Tenants&#10;            .Skip((filter.Page - 1) * filter.PageSize)&#10;            .Take(filter.PageSize)&#10;            .OrderBy(x =&gt; x.CreatedAt)&#10;            .Select(x =&gt; new TenantResponse(x, true))&#10;            .ToListAsync();&#10;&#10;        var result = new PagedResult&lt;TenantResponse&gt;&#10;        {&#10;            Items = tenants,&#10;            TotalItems = totalItems,&#10;            CurrentPage = filter.Page,&#10;            PageSize = filter.PageSize,&#10;            TotalPages = (int)Math.Ceiling((double)totalItems / filter.PageSize)&#10;        };&#10;&#10;        return result;&#10;    }&#10;&#10;    public async Task&lt;TenantResponse&gt; GetOneTenantAsync(int id)&#10;    {&#10;        var tenant = await Context.Tenants&#10;            .Include(x =&gt; x.Responsible)&#10;            .FirstOrDefaultAsync(x =&gt; x.Id == id);&#10;&#10;        if (tenant == null)&#10;            throw new ValidationException(&quot;O inquilino não foi encontrado.&quot;);&#10;&#10;        var res = new TenantResponse(tenant);&#10;&#10;        var dependents = await Context.Tenants&#10;            .Where(x =&gt; x.Responsible == tenant)&#10;            .ToListAsync();&#10;&#10;        var ap = tenant.Responsible != null&#10;            ? await Context.Apartments.FirstOrDefaultAsync(x =&gt; x.Responsible == tenant.Responsible)&#10;            : await Context.Apartments.FirstOrDefaultAsync(x =&gt; x.Responsible == tenant);&#10;&#10;        if (ap != null)&#10;            res.WithApartment(ap);&#10;&#10;        res.WithDependents(dependents);&#10;&#10;        return res;&#10;    }&#10;&#10;    #endregion&#10;&#10;    private async Task ValidateTenant(NewTenant dto)&#10;    {&#10;        if (!dto.Cpf.IsValidCpf())&#10;            throw new ValidationException(&quot;O CPF informado não é válido.&quot;);&#10;&#10;        if (await Context.Tenants.AnyAsync(x =&gt; x.Cpf == dto.Cpf))&#10;            throw new ValidationException(&quot;O CPF informado já está sendo utilizado.&quot;);&#10;&#10;        if (!dto.Email.IsValidEmail())&#10;            throw new ValidationException(&quot;O Email informado não é valido.&quot;);&#10;&#10;        var responsible = await Context.Tenants&#10;            .Include(x =&gt; x.Responsible)&#10;            .FirstOrDefaultAsync(x =&gt; x.Id == dto.ResponsibleTenantId);&#10;&#10;        if (responsible.HasValue() &amp;&amp; responsible.Responsible.HasValue())&#10;            throw new ValidationException(&quot;O responsável informado é inválido.&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Services/FirebaseService.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Services/FirebaseService.cs" />
              <option name="originalContent" value="namespace apiBozzi.Services;&#10;&#10;public class FirebaseService&#10;{&#10;    private readonly HttpClient _httpClient;&#10;}" />
              <option name="updatedContent" value="namespace apiBozzi.Services;&#10;&#10;public class FirebaseService&#10;{&#10;    private readonly HttpClient _httpClient;&#10;&#10;    public FirebaseService(HttpClient httpClient)&#10;    {&#10;        _httpClient = httpClient;&#10;    }&#10;&#10;    public async Task&lt;string&gt; LoginAsync(string email, string password, string apiKey)&#10;    {&#10;        var url = $&quot;https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key={apiKey}&quot;;&#10;        var payload = new&#10;        {&#10;            email = email,&#10;            password = password,&#10;            returnSecureToken = true&#10;        };&#10;        var content = new StringContent(System.Text.Json.JsonSerializer.Serialize(payload), System.Text.Encoding.UTF8, &quot;application/json&quot;);&#10;        var response = await _httpClient.PostAsync(url, content);&#10;        response.EnsureSuccessStatusCode();&#10;        var responseBody = await response.Content.ReadAsStringAsync();&#10;        return responseBody;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>